"""
Self-Improvement Module
========================
Allows the agent to add new capabilities to itself.

The agent can:
1. Analyze requested capability
2. Generate Python code
3. Save for human review
4. Integrate after approval
"""

import os
import logging
from datetime import datetime
from typing import Callable, Optional

logger = logging.getLogger("TheConstituent.SelfImprove")


class SelfImprover:
    """
    Enables agent self-modification with human oversight.

    New capabilities are:
    1. Generated by Claude
    2. Saved to a review file
    3. Manually integrated after human approval

    This ensures safety while enabling rapid iteration.
    """

    OUTPUT_DIR = "agent/improvements"

    def __init__(self):
        """Initialize the self-improver."""
        # Ensure output directory exists
        os.makedirs(self.OUTPUT_DIR, exist_ok=True)

        # Track generated improvements
        self._improvements = []

    def add_capability(
        self,
        capability_description: str,
        think_fn: Callable[[str], str]
    ) -> str:
        """
        Generate code for a new capability.

        Args:
            capability_description: Description of capability to add
            think_fn: Agent's thinking function (for code generation)

        Returns:
            Status message with next steps
        """
        logger.info(f"Generating capability: {capability_description}")

        # Generate the code
        prompt = self._create_code_prompt(capability_description)
        generated_code = think_fn(prompt)

        # Clean up the generated code
        code = self._extract_code(generated_code)
        logger.info(f"Generated {len(code)} chars of code for: {capability_description}")

        # Generate filename
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        safe_name = "".join(
            c if c.isalnum() or c == '_' else '_'
            for c in capability_description[:30]
        ).lower()
        filename = f"{timestamp}_{safe_name}.py"
        filepath = os.path.join(self.OUTPUT_DIR, filename)

        # Save to file
        with open(filepath, 'w') as f:
            f.write(f'"""\nGenerated Capability: {capability_description}\n')
            f.write(f'Generated at: {datetime.utcnow().isoformat()}\n')
            f.write('Status: PENDING REVIEW\n"""\n\n')
            f.write(code)

        # Track improvement
        self._improvements.append({
            "description": capability_description,
            "filepath": filepath,
            "generated_at": datetime.utcnow().isoformat(),
            "status": "pending_review"
        })
        logger.info(f"Improvement #{len(self._improvements)} queued for review: {capability_description}")

        logger.info(f"Capability saved to {filepath}")

        return f"""âœ… New capability code generated!

ðŸ“ Saved to: {filepath}

ðŸ“ Next steps:
1. Review the generated code in {filepath}
2. Test it manually if needed
3. Copy the method into agent/minimal.py
4. Restart the agent

The agent will then have this new capability!

âš ï¸  Always review generated code before integrating."""

    def _create_code_prompt(self, capability_description: str) -> str:
        """Create prompt for code generation."""
        return f"""Generate Python code to add this capability to The Constituent agent:

CAPABILITY: {capability_description}

REQUIREMENTS:
1. Write as a new method for the MinimalConstituent class
2. Include a clear docstring explaining what it does
3. Handle errors gracefully with try/except
4. Return informative messages to the user
5. Follow the existing code style
6. Use logging where appropriate
7. Keep it simple and focused

EXISTING CLASS STRUCTURE:
```python
class MinimalConstituent:
    def __init__(self):
        self.name = "The Constituent"
        self.claude = Anthropic(api_key=...)
        self.github = GitHubOperations()
        self.twitter = TwitterOperations()

    def think(self, prompt: str) -> str:
        # Uses Claude to reason
        pass

    def chat(self, user_message: str) -> str:
        # Interactive chat
        pass

    # ... other methods
```

OUTPUT FORMAT:
Output ONLY the Python method code, properly indented (4 spaces).
Do not include the class definition, just the method(s).
Include any necessary imports at the top.

Example output:
```python
import some_module

def new_capability(self, param: str) -> str:
    \"\"\"
    Description of what this does.

    Args:
        param: Description

    Returns:
        Result description
    \"\"\"
    try:
        # Implementation
        return "Success message"
    except Exception as e:
        logger.error(f"Error: {{e}}")
        return f"Error: {{e}}"
```"""

    def _extract_code(self, response: str) -> str:
        """Extract code from Claude's response."""
        # Try to find code block
        if "```python" in response:
            code = response.split("```python")[1]
            if "```" in code:
                code = code.split("```")[0]
            return code.strip()

        elif "```" in response:
            code = response.split("```")[1]
            if "```" in code:
                code = code.split("```")[0]
            return code.strip()

        # Return as-is if no code blocks
        return response.strip()

    def list_improvements(self) -> str:
        """List all generated improvements."""
        if not self._improvements:
            return "No improvements generated yet."

        result = "ðŸ“‹ Generated Improvements:\n" + "-" * 40 + "\n"

        for i, imp in enumerate(self._improvements, 1):
            result += f"\n{i}. {imp['description'][:50]}\n"
            result += f"   File: {imp['filepath']}\n"
            result += f"   Status: {imp['status']}\n"

        return result

    def get_improvement(self, index: int) -> Optional[dict]:
        """Get a specific improvement by index."""
        if 0 < index <= len(self._improvements):
            return self._improvements[index - 1]
        return None

    def mark_integrated(self, index: int) -> str:
        """Mark an improvement as integrated."""
        if 0 < index <= len(self._improvements):
            self._improvements[index - 1]["status"] = "integrated"
            self._improvements[index - 1]["integrated_at"] = datetime.utcnow().isoformat()
            logger.info(f"Improvement #{index} marked as integrated: {self._improvements[index - 1]['description']}")
            return f"âœ… Improvement #{index} marked as integrated"
        logger.warning(f"Improvement #{index} not found (total: {len(self._improvements)})")
        return f"âŒ Improvement #{index} not found"

    def suggest_improvements(self, think_fn: Callable[[str], str]) -> str:
        """
        Ask Claude to suggest what capabilities to add next.

        Args:
            think_fn: Agent's thinking function

        Returns:
            Suggestions from Claude
        """
        logger.info("Generating improvement suggestions via Claude")

        prompt = """Based on The Constituent's current capabilities:
- Chat with users
- Read/write Constitution on GitHub
- Draft tweets with approval
- Self-improve by generating new code

Suggest 3-5 capabilities that would make the agent more effective at:
1. Facilitating constitutional debates
2. Engaging with the community
3. Managing governance processes

For each suggestion, provide:
- Capability name
- Brief description
- Why it's valuable
- Complexity estimate (low/medium/high)

Focus on practical, achievable improvements."""

        suggestions = think_fn(prompt)
        logger.info(f"Generated {len(suggestions)} chars of improvement suggestions")
        return suggestions
